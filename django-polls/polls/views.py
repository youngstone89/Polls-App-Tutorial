from django.shortcuts import render, get_object_or_404 
from django.http import HttpResponse, Http404, HttpResponseRedirect
from django.urls import reverse
from .models import Question, Choice
from django.template import loader
from django.db.models import F
from django.views import generic
from django.utils import timezone



# Create your views here.


#1 Not Using Generic View
# def index(request):

# 	#1 Basic View Page with the list of string
# 	#output= ',	'.join([q.question_text for q in latest_question_list])

# 	#2 Separating View Template, passing context parameter 
# 	# latest_question_list = Question.objects.order_by('-pub_date');
# 	# template = loader.get_template('polls/index.html')
# 	# context = {'latest_question_list': latest_question_list,}
# 	# return HttpResponse(template.render(context,request))

# 	#3 Shortcut Rendering
# 	latest_question_list = Question.objects.order_by('-pub_date');
# 	context = {'latest_question_list': latest_question_list}
# 	return render(request, 'polls/index.html',context)


#2 Using Generic View
class IndexView(generic.ListView):
	template_name = 'polls/index.html'

	#for ListView, the automatically generated context variable is question_list. 
	#To override this we provide the context_object_name attribute, 
	#specifying that we want to use latest_question_list instead.
	context_object_name= 'latest_question_list'


	#we need to amend the get_queryset() method and change it so that it also checks the date by comparing it with timezone.now()
	def get_queryset(self):
		"""Return the last five publihsed questions.
		Not including those set to be published in the future
		"""
		#__lte suffix means Less Than Equals To <= 
		return Question.objects.filter(pub_date__lte = timezone.now()).order_by('-pub_date')[:5]

#1 Not Using Generic View
# def detail(request, question_id):
# 	#1 Raise Http404 Exception in case there is no corresponding object
# 	# try:
# 	# 	question = Question.objects.get(pk=question_id)
# 	# 	context = {'question':question}
# 	# except Question.DoesNotExist:
# 	# 	raise Http404('Question does not exist')
# 	# return render(request,'polls/detail.html',context)

# 	#2 Simple Shortcut to get object or raise 404 error
# 	question = get_object_or_404(Question,pk=question_id)
# 	return render(request,'polls/detail.html',{'question':question})
# 	#3 Get list object or raise 404
# 	# get_list_or_404() function can be used


#2 Using Generic View
class DetailView(generic.DetailView):
	#Each Generic View needs to know what model it will be acting upon
	model = Question
	#Default Template Name called by Generic View is <app name>/<model name>_detail.html
	#But template_name attribute can be used to tell Django to use a specific template name instead of autogenerated default name
	template_name = 'polls/detail.html'

	def get_queryset(self):
		"""
		Excludes any questions that aren't published yet.
		"""
		return Question.objects.filter(pub_date__lte=timezone.now())


#1 Not using Generic View
# def results(request, question_id):
# 	#1 Simple HttpResponse for Test
#     #response = "You're looking at the results of question %s."
#     # return HttpResponse(response % question_id)
#     question = Question.objects.get(pk=question_id)
#     return render(request, 'polls/results.html',{'question':question})
class ResultsView(generic.DetailView):
	model = Question
	template_name = 'polls/results.html'

def vote(request, question_id):
	
	question = get_object_or_404(Question,pk=question_id)
	
	try:
		#request POST['']: a dictionary like object that lets you access submitted data by key name, return values are always strings
		#In the same way, request GET[''] also available
		selected_choice = question.choice_set.get(pk=request.POST['choice'])

		#KeyError pertains to Ditionary Key's value, it raises error if the Key's value is not submitted. 
	except (KeyError, Choice.DoesNotExist):
		return render(request,'polls/detail.html',{'question':question,'error_message':'You didn\'t select a choice.',})
	else:
		# The code for our vote() view does have a small problem. 
		# It first gets the selected_choice object from the database, 
		# then computes the new value of votes, and then saves it back to the database. 
		# If two users of your website try to vote at exactly the same time, this might go wrong: 
		# The same value, letâ€™s say 42, will be retrieved for votes. 
		# Then, for both users the new value of 43 is computed and saved, 
		# but 44 would be the expected value.
		
		#1 Not Avoiding Race Conditions
		# selected_choice.votes+= 1
		# selected_choice.save()

		#2 Avoidng Race Conditions
		# use F()  it overrides the standard Python operators to create an encapsulated SQL expression
		selected_choice.votes = F('votes') + 1
		selected_choice.save()

		#HttpResponseRedirect take a single argument: the URL to which the user will be redirected 
		#Reverse() funtion helps avoid having to hardcode a URL in view function
		#Rerverse() takes argument: name of view that we want to pass control to and variable portion of the URL pattern
		return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))